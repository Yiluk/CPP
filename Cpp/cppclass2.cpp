#include <iostream>

using namespace std;

/*
	拷贝构造函数：
	拷贝构造函数是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。
	拷贝构造函数通常用于：
		通过使用另一个同类型的对象来初始化新创建的对象。
		复制对象把它作为参数传递给函数。
		复制对象，并从函数返回这个对象。
	如果在类中没有定义拷贝构造函数，编译器会自行定义一个。如果类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数。

	关于为什么当类成员中含有指针类型成员且需要对其分配内存时，一定要有总定义拷贝构造函数？？
	默认的拷贝构造函数实现的只能是浅拷贝，即直接将原对象的数据成员值依次复制给新对象中对应的数据成员，并没有为新对象另外分配内存资源。
	这样，如果对象的数据成员是指针，两个指针对象实际上指向的是同一块内存空间。
	在某些情况下，浅拷贝回带来数据安全方面的隐患。
	当类的数据成员中有指针类型时，我们就必须定义一个特定的拷贝构造函数，该拷贝构造函数不仅可以实现原对象和新对象之间数据成员的拷贝，而且可以为新的对象分配单独的内存资源，这就是深拷贝构造函数。
	如何防止默认拷贝发生
	声明一个私有的拷贝构造函数，这样因为拷贝构造函数是私有的，如果用户试图按值传递或函数返回该类的对象，编译器会报告错误，从而可以避免按值传递或返回对象。

	总结：
	当出现类的等号赋值时，会调用拷贝函数，在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的。
	但当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象。所以，这时，必须采用深拷贝。
	深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来储存数据，从而也就解决了指针悬挂的问题。简而言之，当数据成员中有指针时，必须要用深拷贝。
*/

class Box
{
private:
	int *iptr;

public:
	//构造函数声明
	Box(int ptrLen);
	//拷贝构造函数
	Box(const Box &obj);
	//析构函数声明
	~Box();
	//成员函数声明
	int getPtrLen();
};

Box::Box(int ptrLen)
{
	cout << "调用构造函数为指针分配内存" << endl;
	iptr = new int;
	*iptr = ptrLen;
}

Box::Box(const Box &obj)
{
	cout << "调用拷贝函数为指针ptr分配内存" << endl;
	iptr = new int;
	*iptr = *obj.iptr; //拷贝值
}

Box::~Box()
{
	cout << "destruct function" << endl;
	delete iptr; //使用delete释放内存，使用new分配的内存一定要使用delete释放，否则会有内存泄漏。内存释放分为隐式与显式，隐式为程序运行完后自动释放，显式需要去手动释放。
}

int Box::getPtrLen()
{
	return *iptr;
}

void testmain()
{
	cout << "1111111111111" << endl;
	cout << "----------------------------------------------------------------" << endl;
	Box Box1(100);
	Box Box2 = Box1;
	cout << "Box1 iptr 大小 : " << Box1.getPtrLen() << endl;
	cout << "Box2 iptr 大小 : " << Box2.getPtrLen() << endl;
	cout << "----------------------------------------------------------------" << endl;
}

int main()
{
	testmain();
	system("pause");
	return 0;
}